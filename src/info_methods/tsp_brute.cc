#include <iostream>
#include <ctime>
#include <cmath>
#include <iomanip>
#include <fstream>

#include "info_methods/tsp_brute.h"

std::vector<int> tsp_path(const std::string &distance_filename) {
  double *distance;
  int i;
  int i1;
  int i2;
  int m;
  bool more;
  int n;
  int *p;
  int *p_min;
  int paths;
  double total;
  double total_ave;
  double total_max;
  double total_min;

  timestamp();
//  std::cout << "\n";
//  std::cout << "TSP_BRUTE:\n";
//  std::cout << "  C++ version\n";
//  std::cout << "  Solve small traveling salesman problems by brute force.\n";
  //
  //  Get the distance table.
  //
//  std::cout << "\n";
//  std::cout << "  Enter the name of the file containing\n";
//  std::cout << "  the city-to-city distance table.\n";

  r8mat_header_read(distance_filename, m, n);

//  std::cout << "\n";
//  std::cout << "  Number of cities is " << n << "\n";

  distance = r8mat_data_read(distance_filename, n, n);
  //
  //  Print the distance matrix.
  //
//  r8mat_print(n, n, distance, "  Distance matrix:");
  //
  //  Examine every permutation.
  //
  total_max = -r8_huge();
  total_min = r8_huge();
  total_ave = 0.0;

  more = false;
  p = new int[n];
  p_min = new int[n];

  paths = 0;

  for (;;) {
    perm_next3(n, p, more);

    paths = paths + 1;

    total = 0.0;
    i1 = n - 1;
    for (i2 = 0; i2 < n; i2++) {
      total = total + distance[p[i1] + p[i2] * n];
      i1 = i2;
    }

    total_ave = total_ave + total;

    if (total_max < total) {
      total_max = total;
    }

    if (total < total_min) {
      total_min = total;
      for (i = 0; i < n; i++) {
        p_min[i] = p[i];
      }
    }

    if (!more) {
      break;
    }

  }

  total_ave = total_ave / (double) (paths);

  std::vector<int> path;
//  std::cout << "\n";
//  std::cout << "  Itinerary:\n";
//  std::cout << "  Step  From  To    Distance\n";
//  std::cout << "\n";
  i1 = n - 1;
  for (i2 = 0; i2 < n; i2++) {
//    std::cout << "  " << std::setw(4) << i2
//            << "    " << std::setw(2) << p_min[i1]
//            << "  " << std::setw(2) << p_min[i2]
//            << "  " << distance[p_min[i1] + p_min[i2] * n] << "\n";
    path.push_back(p_min[i1]);
    i1 = i2;
  }
//  std::cout << "\n";
//  std::cout << "  Total:         " << total_min << "\n";
//
//  std::cout << "\n";
//  std::cout << "  Number of paths checked = " << paths << "\n";
//  std::cout << "\n";
//  std::cout << "  Minimum length = " << total_min << "\n";
//  std::cout << "  Average length = " << total_ave << "\n";
//  std::cout << "  Maximum length = " << total_max << "\n";
  //
  //  Free memory.
  //
  delete [] distance;
  delete [] p;
  delete [] p_min;
  /*
    Terminate.
   */
//  std::cout << "\n";
//  std::cout << "TSP_BRUTE\n";
//  std::cout << "  Normal end of execution.\n";
//  std::cout << "\n";
  timestamp();
  return path;
}

char ch_cap(char ch)

//****************************************************************************80
//
//  Purpose:
//
//    CH_CAP capitalizes a single character.
//
//  Discussion:
//
//    This routine should be equivalent to the library "toupper" function.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    19 July 1998
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, char CH, the character to capitalize.
//
//    Output, char CH_CAP, the capitalized character.
//
{
  if (97 <= ch && ch <= 122) {
    ch = ch - 32;
  }

  return ch;
}
//****************************************************************************80

bool ch_eqi(char ch1, char ch2)

//****************************************************************************80
//
//  Purpose:
//
//    CH_EQI is true if two characters are equal, disregarding case.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    13 June 2003
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, char CH1, CH2, the characters to compare.
//
//    Output, bool CH_EQI, is true if the two characters are equal,
//    disregarding case.
//
{
  if (97 <= ch1 && ch1 <= 122) {
    ch1 = ch1 - 32;
  }
  if (97 <= ch2 && ch2 <= 122) {
    ch2 = ch2 - 32;
  }

  return ( ch1 == ch2);
}
//****************************************************************************80

int ch_to_digit(char ch)

//****************************************************************************80
//
//  Purpose:
//
//    CH_TO_DIGIT returns the integer value of a base 10 digit.
//
//  Example:
//
//     CH  DIGIT
//    ---  -----
//    '0'    0
//    '1'    1
//    ...  ...
//    '9'    9
//    ' '    0
//    'X'   -1
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    13 June 2003
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, char CH, the decimal digit, '0' through '9' or blank are legal.
//
//    Output, int CH_TO_DIGIT, the corresponding integer value.  If the
//    character was 'illegal', then DIGIT is -1.
//
{
  int digit;

  if ('0' <= ch && ch <= '9') {
    digit = ch - '0';
  } else if (ch == ' ') {
    digit = 0;
  } else {
    digit = -1;
  }

  return digit;
}
//****************************************************************************80

int file_column_count(std::string filename)

//****************************************************************************80
//
//  Purpose:
//
//    FILE_COLUMN_COUNT counts the columns in the first line of a file.
//
//  Discussion:
//
//    The file is assumed to be a simple text file.
//
//    Most lines of the file are presumed to consist of COLUMN_NUM words,
//    separated by spaces.  There may also be some blank lines, and some
//    comment lines, which have a "#" in column 1.
//
//    The routine tries to find the first non-comment non-blank line and
//    counts the number of words in that line.
//
//    If all lines are blanks or comments, it goes back and tries to analyze
//    a comment line.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    05 July 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string FILENAME, the name of the file.
//
//    Output, int FILE_COLUMN_COUNT, the number of columns assumed
//    to be in the file.
//
{
  int column_num;
  std::ifstream input;
  bool got_one;
  std::string text;
  //
  //  Open the file.
  //
  input.open(filename.c_str());

  if (!input) {
    column_num = -1;
    std::cerr << "\n";
    std::cerr << "FILE_COLUMN_COUNT - Fatal error!\n";
    std::cerr << "  Could not open the file:\n";
    std::cerr << "  \"" << filename << "\"\n";
    exit(1);
  }
  //
  //  Read one line, but skip blank lines and comment lines.
  //
  got_one = false;

  for (;;) {
    std::getline(input, text);

    if (input.eof()) {
      break;
    }

    if (s_len_trim(text) <= 0) {
      continue;
    }

    if (text[0] == '#') {
      continue;
    }
    got_one = true;
    break;
  }

  if (!got_one) {
    input.close();

    input.open(filename.c_str());

    for (;;) {
      input >> text;

      if (input.eof()) {
        break;
      }

      if (s_len_trim(text) == 0) {
        continue;
      }
      got_one = true;
      break;
    }
  }

  input.close();

  if (!got_one) {
    std::cerr << "\n";
    std::cerr << "FILE_COLUMN_COUNT - Warning!\n";
    std::cerr << "  The file does not seem to contain any data.\n";
    return -1;
  }

  column_num = s_word_count(text);

  return column_num;
}
//****************************************************************************80

int file_row_count(std::string input_filename)

//****************************************************************************80
//
//  Purpose:
//
//    FILE_ROW_COUNT counts the number of row records in a file.
//
//  Discussion:
//
//    It does not count lines that are blank, or that begin with a
//    comment symbol '#'.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    23 February 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string INPUT_FILENAME, the name of the input file.
//
//    Output, int FILE_ROW_COUNT, the number of rows found.
//
{
  int bad_num;
  int comment_num;
  std::ifstream input;
  int i;
  std::string line;
  int record_num;
  int row_num;

  row_num = 0;
  comment_num = 0;
  record_num = 0;
  bad_num = 0;

  input.open(input_filename.c_str());

  if (!input) {
    std::cerr << "\n";
    std::cerr << "FILE_ROW_COUNT - Fatal error!\n";
    std::cerr << "  Could not open the input file: \"" << input_filename << "\"\n";
    exit(1);
  }

  for (;;) {
    std::getline(input, line);

    if (input.eof()) {
      break;
    }

    record_num = record_num + 1;

    if (line[0] == '#') {
      comment_num = comment_num + 1;
      continue;
    }

    if (s_len_trim(line) == 0) {
      comment_num = comment_num + 1;
      continue;
    }

    row_num = row_num + 1;

  }

  input.close();

  return row_num;
}
//****************************************************************************80

void perm_next3(int n, int p[], bool &more)

//****************************************************************************80
//
//  Purpose:
//
//    PERM_NEXT3 computes all of the permutations of N objects, one at a time.
//
//  Discussion:
//
//    The routine is initialized by calling with MORE = TRUE in which case
//    it returns the identity permutation.
//
//    If the routine is called with MORE = FALSE then the successor of the
//    input permutation is computed.
//
//    Trotter's algorithm is used.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license. 
//
//  Modified:
//
//    06 July 2003
//
//  Author:
//
//    Original FORTRAN77 version by H Trotter,
//    C++ version by John Burkardt.
//
//  Reference:
//
//    H Trotter,
//    PERM, Algorithm 115,
//    Communications of the Association for Computing Machinery,
//    Volume 5, 1962, pages 434-435.
//
//  Parameters:
//
//    Input, int N, the number of objects being permuted.
//
//    Input/output, int P[N], the permutation, in standard index form.
//    If MORE is TRUE, then P is assumed to contain the
//    "previous" permutation, and on P(I) is the value
//    of the I-th object under the next permutation.
//    Otherwise, P will be set to the "first" permutation.
//
//    Input/output, bool &MORE.
//    Set MORE = FALSE before first calling this routine.
//    MORE will be reset to TRUE and a permutation will be returned.
//    Each new call produces a new permutation until MORE is returned FALSE
//
{
  int i;
  int m2;
  int n2;
  static int nfact = 0;
  int q;
  static int rank = 0;
  int s;
  int t;
  int temp;

  if (!more) {
    for (i = 0; i < n; i++) {
      p[i] = i;
    }
    more = true;
    rank = 1;

    nfact = 1;
    for (i = 1; i <= n; i++) {
      nfact = nfact * i;
    }
  } else {
    n2 = n;
    m2 = rank;
    s = n;

    for (;;) {
      q = m2 % n2;
      t = m2 % (2 * n2);

      if (q != 0) {
        break;
      }

      if (t == 0) {
        s = s - 1;
      }

      m2 = m2 / n2;
      n2 = n2 - 1;

    }

    if (q == t) {
      s = s - q;
    } else {
      s = s + q - n2;
    }

    temp = p[s - 1];
    p[s - 1] = p[s];
    p[s] = temp;

    rank = rank + 1;

    if (rank == nfact) {
      more = false;
    }
  }

  return;
}
//****************************************************************************80

double r8_huge()

//****************************************************************************80
//
//  Purpose:
//
//    R8_HUGE returns a "huge" R8.
//
//  Discussion:
//
//    The value returned by this function is NOT required to be the
//    maximum representable R8.  This value varies from machine to machine,
//    from compiler to compiler, and may cause problems when being printed.
//    We simply want a "very large" but non-infinite number.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    06 October 2007
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Output, double R8_HUGE, a "huge" R8 value.
//
{
  double value;

  value = 1.0E+30;

  return value;
}
//****************************************************************************80

double *r8mat_data_read(std::string input_filename, int m, int n)

//****************************************************************************80
//
//  Purpose:
//
//    R8MAT_DATA_READ reads the data from an R8MAT file.
//
//  Discussion:
//
//    An R8MAT is an array of R8's.
//
//    The file is assumed to contain one record per line.
//
//    Records beginning with '#' are comments, and are ignored.
//    Blank lines are also ignored.
//
//    Each line that is not ignored is assumed to contain exactly (or at least)
//    M real numbers, representing the coordinates of a point.
//
//    There are assumed to be exactly (or at least) N such records.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    23 February 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string INPUT_FILENAME, the name of the input file.
//
//    Input, int M, the number of spatial dimensions.
//
//    Input, int N, the number of points.  The program
//    will stop reading data once N values have been read.
//
//    Output, double R8MAT_DATA_READ[M*N], the data.
//
{
  bool error;
  std::ifstream input;
  int i;
  int j;
  std::string line;
  double *table;
  double *x;

  input.open(input_filename.c_str());

  if (!input) {
    std::cerr << "\n";
    std::cerr << "R8MAT_DATA_READ - Fatal error!\n";
    std::cerr << "  Could not open the input file: \"" << input_filename << "\"\n";
    exit(1);
  }

  table = new double[m * n];

  x = new double[m];

  j = 0;

  while (j < n) {
    std::getline(input, line);

    if (input.eof()) {
      break;
    }

    if (line[0] == '#' || s_len_trim(line) == 0) {
      continue;
    }

    error = s_to_r8vec(line, m, x);

    if (error) {
      continue;
    }

    for (i = 0; i < m; i++) {
      table[i + j * m] = x[i];
    }
    j = j + 1;

  }

  input.close();

  delete [] x;

  return table;
}
//****************************************************************************80

void r8mat_header_read(std::string input_filename, int &m, int &n)

//****************************************************************************80
//
//  Purpose:
//
//    R8MAT_HEADER_READ reads the header from an R8MAT file.
//
//  Discussion:
//
//    An R8MAT is an array of R8's.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    04 December 2013
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string INPUT_FILENAME, the name of the input file.
//
//    Output, int &M, the number of spatial dimensions.
//
//    Output, int &N, the number of points.
//
{
  m = file_column_count(input_filename);

  if (m <= 0) {
    std::cerr << "\n";
    std::cerr << "R8MAT_HEADER_READ - Fatal error!\n";
    std::cerr << "  FILE_COLUMN_COUNT failed.\n";
    exit(1);
  }

  n = file_row_count(input_filename);

  if (n <= 0) {
    std::cerr << "\n";
    std::cerr << "R8MAT_HEADER_READ - Fatal error!\n";
    std::cerr << "  FILE_ROW_COUNT failed.\n";
    exit(1);
  }

  return;
}
//****************************************************************************80

void r8mat_print(int m, int n, double a[], std::string title)

//****************************************************************************80
//
//  Purpose:
//
//    R8MAT_PRINT prints an R8MAT, with an optional title.
//
//  Discussion:
//
//    An R8MAT is an array of R8's.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    29 August 2003
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, int M, the number of rows in A.
//
//    Input, int N, the number of columns in A.
//
//    Input, double A[M*N], the M by N matrix.
//
//    Input, string TITLE, a title.
//
{
  r8mat_print_some(m, n, a, 1, 1, m, n, title);

  return;
}
//****************************************************************************80

void r8mat_print_some(int m, int n, double a[], int ilo, int jlo, int ihi, int jhi, std::string title)

//****************************************************************************80
//
//  Purpose:
//
//    R8MAT_PRINT_SOME prints some of an R8MAT.
//
//  Discussion:
//
//    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
//    in column-major order.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    26 June 2013
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, int M, the number of rows of the matrix.
//    M must be positive.
//
//    Input, int N, the number of columns of the matrix.
//    N must be positive.
//
//    Input, double A[M*N], the matrix.
//
//    Input, int ILO, JLO, IHI, JHI, designate the first row and
//    column, and the last row and column to be printed.
//
//    Input, string TITLE, a title.
//
{
#define INCX 5

  int i;
  int i2hi;
  int i2lo;
  int j;
  int j2hi;
  int j2lo;

  std::cout << "\n";
  std::cout << title << "\n";

  if (m <= 0 || n <= 0) {
    std::cout << "\n";
    std::cout << "  (None)\n";
    return;
  }
  //
  //  Print the columns of the matrix, in strips of 5.
  //
  for (j2lo = jlo; j2lo <= jhi; j2lo = j2lo + INCX) {
    j2hi = j2lo + INCX - 1;
    if (n < j2hi) {
      j2hi = n;
    }
    if (jhi < j2hi) {
      j2hi = jhi;
    }
    std::cout << "\n";
    //
    //  For each column J in the current range...
    //
    //  Write the header.
    //
    std::cout << "  Col:    ";
    for (j = j2lo; j <= j2hi; j++) {
      std::cout << std::setw(7) << j - 1 << "       ";
    }
    std::cout << "\n";
    std::cout << "  Row\n";
    std::cout << "\n";
    //
    //  Determine the range of the rows in this strip.
    //
    if (1 < ilo) {
      i2lo = ilo;
    } else {
      i2lo = 1;
    }
    if (ihi < m) {
      i2hi = ihi;
    } else {
      i2hi = m;
    }

    for (i = i2lo; i <= i2hi; i++) {
      //
      //  Print out (up to) 5 entries in row I, that lie in the current strip.
      //
      std::cout << std::setw(5) << i - 1 << ": ";
      for (j = j2lo; j <= j2hi; j++) {
        std::cout << std::setw(12) << a[i - 1 + (j - 1) * m] << "  ";
      }
      std::cout << "\n";
    }
  }

  return;
#undef INCX
}
//****************************************************************************80

int s_len_trim(std::string s)

//****************************************************************************80
//
//  Purpose:
//
//    S_LEN_TRIM returns the length of a string to the last nonblank.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    05 July 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string S, a string.
//
//    Output, int S_LEN_TRIM, the length of the string to the last nonblank.
//    If S_LEN_TRIM is 0, then the string is entirely blank.
//
{
  int n;

  n = s.length();

  while (0 < n) {
    if (s[n - 1] != ' ') {
      return n;
    }
    n = n - 1;
  }

  return n;
}
//****************************************************************************80

double s_to_r8(std::string s, int *lchar, bool *error)

//****************************************************************************80
//
//  Purpose:
//
//    S_TO_R8 reads an R8 from a string.
//
//  Discussion:
//
//    This routine will read as many characters as possible until it reaches
//    the end of the string, or encounters a character which cannot be
//    part of the real number.
//
//    Legal input is:
//
//       1 blanks,
//       2 '+' or '-' sign,
//       2.5 spaces
//       3 integer part,
//       4 decimal point,
//       5 fraction part,
//       6 'E' or 'e' or 'D' or 'd', exponent marker,
//       7 exponent sign,
//       8 exponent integer part,
//       9 exponent decimal point,
//      10 exponent fraction part,
//      11 blanks,
//      12 final comma or semicolon.
//
//    with most quantities optional.
//
//  Example:
//
//    S                 R
//
//    '1'               1.0
//    '     1   '       1.0
//    '1A'              1.0
//    '12,34,56'        12.0
//    '  34 7'          34.0
//    '-1E2ABCD'        -100.0
//    '-1X2ABCD'        -1.0
//    ' 2E-1'           0.2
//    '23.45'           23.45
//    '-4.2E+2'         -420.0
//    '17d2'            1700.0
//    '-14e-2'         -0.14
//    'e2'              100.0
//    '-12.73e-9.23'   -12.73 * 10.0^(-9.23)
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    05 July 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string S, the string containing the
//    data to be read.  Reading will begin at position 1 and
//    terminate at the end of the string, or when no more
//    characters can be read to form a legal real.  Blanks,
//    commas, or other nonnumeric data will, in particular,
//    cause the conversion to halt.
//
//    Output, int *LCHAR, the number of characters read from
//    the string to form the number, including any terminating
//    characters such as a trailing comma or blanks.
//
//    Output, bool *ERROR, is true if an error occurred.
//
//    Output, double S_TO_R8, the real value that was read from the string.
//
{
  char c;
  int ihave;
  int isgn;
  int iterm;
  int jbot;
  int jsgn;
  int jtop;
  int nchar;
  int ndig;
  double r;
  double rbot;
  double rexp;
  double rtop;
  char TAB = 9;

  nchar = s_len_trim(s);
  *error = false;
  r = 0.0;
  *lchar = -1;
  isgn = 1;
  rtop = 0.0;
  rbot = 1.0;
  jsgn = 1;
  jtop = 0;
  jbot = 1;
  ihave = 1;
  iterm = 0;

  for (;;) {
    c = s[*lchar + 1];
    *lchar = *lchar + 1;
    //
    //  Blank or TAB character.
    //
    if (c == ' ' || c == TAB) {
      if (ihave == 2) {
      } else if (ihave == 6 || ihave == 7) {
        iterm = 1;
      } else if (1 < ihave) {
        ihave = 11;
      }
    }//
      //  Comma.
      //
    else if (c == ',' || c == ';') {
      if (ihave != 1) {
        iterm = 1;
        ihave = 12;
        *lchar = *lchar + 1;
      }
    }//
      //  Minus sign.
      //
    else if (c == '-') {
      if (ihave == 1) {
        ihave = 2;
        isgn = -1;
      } else if (ihave == 6) {
        ihave = 7;
        jsgn = -1;
      } else {
        iterm = 1;
      }
    }//
      //  Plus sign.
      //
    else if (c == '+') {
      if (ihave == 1) {
        ihave = 2;
      } else if (ihave == 6) {
        ihave = 7;
      } else {
        iterm = 1;
      }
    }//
      //  Decimal point.
      //
    else if (c == '.') {
      if (ihave < 4) {
        ihave = 4;
      } else if (6 <= ihave && ihave <= 8) {
        ihave = 9;
      } else {
        iterm = 1;
      }
    }//
      //  Exponent marker.
      //
    else if (ch_eqi(c, 'E') || ch_eqi(c, 'D')) {
      if (ihave < 6) {
        ihave = 6;
      } else {
        iterm = 1;
      }
    }//
      //  Digit.
      //
    else if (ihave < 11 && '0' <= c && c <= '9') {
      if (ihave <= 2) {
        ihave = 3;
      } else if (ihave == 4) {
        ihave = 5;
      } else if (ihave == 6 || ihave == 7) {
        ihave = 8;
      } else if (ihave == 9) {
        ihave = 10;
      }

      ndig = ch_to_digit(c);

      if (ihave == 3) {
        rtop = 10.0 * rtop + (double) ndig;
      } else if (ihave == 5) {
        rtop = 10.0 * rtop + (double) ndig;
        rbot = 10.0 * rbot;
      } else if (ihave == 8) {
        jtop = 10 * jtop + ndig;
      } else if (ihave == 10) {
        jtop = 10 * jtop + ndig;
        jbot = 10 * jbot;
      }

    }//
      //  Anything else is regarded as a terminator.
      //
    else {
      iterm = 1;
    }
    //
    //  If we haven't seen a terminator, and we haven't examined the
    //  entire string, go get the next character.
    //
    if (iterm == 1 || nchar <= *lchar + 1) {
      break;
    }

  }
  //
  //  If we haven't seen a terminator, and we have examined the
  //  entire string, then we're done, and LCHAR is equal to NCHAR.
  //
  if (iterm != 1 && (*lchar) + 1 == nchar) {
    *lchar = nchar;
  }
  //
  //  Number seems to have terminated.  Have we got a legal number?
  //  Not if we terminated in states 1, 2, 6 or 7!
  //
  if (ihave == 1 || ihave == 2 || ihave == 6 || ihave == 7) {
    *error = true;
    return r;
  }
  //
  //  Number seems OK.  Form it.
  //
  if (jtop == 0) {
    rexp = 1.0;
  } else {
    if (jbot == 1) {
      rexp = std::pow(10.0, jsgn * jtop);
    } else {
      rexp = jsgn * jtop;
      rexp = rexp / jbot;
      rexp = std::pow(10.0, rexp);
    }

  }

  r = isgn * rexp * rtop / rbot;

  return r;
}
//****************************************************************************80

bool s_to_r8vec(std::string s, int n, double rvec[])

//****************************************************************************80
//
//  Purpose:
//
//    S_TO_R8VEC reads an R8VEC from a string.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    05 July 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string S, the string to be read.
//
//    Input, int N, the number of values expected.
//
//    Output, double RVEC[N], the values read from the string.
//
//    Output, bool S_TO_R8VEC, is true if an error occurred.
//
{
  int begin;
  bool error;
  int i;
  int lchar;
  int length;

  begin = 0;
  length = s.length();
  error = 0;

  for (i = 0; i < n; i++) {
    rvec[i] = s_to_r8(s.substr(begin, length), &lchar, &error);

    if (error) {
      return error;
    }
    begin = begin + lchar;
    length = length - lchar;
  }

  return error;
}
//****************************************************************************80

int s_word_count(std::string s)

//****************************************************************************80
//
//  Purpose:
//
//    S_WORD_COUNT counts the number of "words" in a string.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    05 July 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, string S, the string to be examined.
//
//    Output, int S_WORD_COUNT, the number of "words" in the string.
//    Words are presumed to be separated by one or more blanks.
//
{
  bool blank;
  int char_count;
  int i;
  int word_count;

  word_count = 0;
  blank = true;

  char_count = s.length();

  for (i = 0; i < char_count; i++) {
    if (isspace(s[i])) {
      blank = true;
    } else if (blank) {
      word_count = word_count + 1;
      blank = false;
    }
  }

  return word_count;
}
//****************************************************************************80

void timestamp()

//****************************************************************************80
//
//  Purpose:
//
//    TIMESTAMP prints the current YMDHMS date as a time stamp.
//
//  Example:
//
//    31 May 2001 09:45:54 AM
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    08 July 2009
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    None
//
{
#define TIME_SIZE 40

  static char time_buffer[TIME_SIZE];
  const struct std::tm *tm_ptr;
  size_t len;
  std::time_t now;

  now = std::time(NULL);
  tm_ptr = std::localtime(&now);

  len = std::strftime(time_buffer, TIME_SIZE, "%d %B %Y %I:%M:%S %p", tm_ptr);

  std::cout << time_buffer << "\n";

  return;
#undef TIME_SIZE
}
